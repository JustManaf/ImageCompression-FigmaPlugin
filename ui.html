<!DOCTYPE html>
<script src="https://cdn.jsdelivr.net/gh/psych0der/pngquantjs@master/demo/pngquant.min.js"></script>
<html>
<head>
  <meta charset="utf-8">
  <title>Image Compression Plugin</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 12px;
      line-height: 1.4;
      color: var(--figma-color-text);
      background: var(--figma-color-bg);
      padding: 16px;
      width: 320px;
      max-width: 320px;
      overflow-x: hidden;
      box-sizing: border-box;
    }

    .header {
      margin-bottom: 16px;
    }

    .title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .selection-status {
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 11px;
      margin-bottom: 16px;
    }

    .selection-status.has-selection {
      background: var(--figma-color-bg-success);
      color: var(--figma-color-text-success);
      border: 1px solid var(--figma-color-border-success);
    }

    .selection-status.no-selection {
      background: var(--figma-color-bg-warning);
      color: var(--figma-color-text-warning);
      border: 1px solid var(--figma-color-border-warning);
    }

    .button {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid var(--figma-color-border);
      border-radius: 6px;
      background: var(--figma-color-bg-secondary);
      color: var(--figma-color-text);
      font-size: 11px;
      cursor: pointer;
      margin-bottom: 8px;
    }

    .button:hover {
      background: var(--figma-color-bg-hover);
    }

    .button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .button.primary {
      background: var(--figma-color-bg-brand);
      color: var(--figma-color-text-onbrand);
      border-color: var(--figma-color-bg-brand);
    }

    .button.primary:hover {
      background: var(--figma-color-bg-brand-hover);
    }

    .images-section {
      margin-bottom: 12px;
    }

    .section-title {
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--figma-color-text);
    }

    .images-list {
      border: 1px solid var(--figma-color-border);
      border-radius: 6px;
      background: var(--figma-color-bg);
      width: 100%;
      max-width: 320px;
      overflow-x: hidden;
      overflow-y: visible;
    }

    .image-item {
      padding: 8px;
      border-bottom: 1px solid var(--figma-color-border);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .image-item:last-child {
      border-bottom: none;
    }

    .image-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .image-name {
      font-size: 11px;
      font-weight: 500;
      color: var(--figma-color-text);
    }

    .image-name-container {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .image-checkbox {
      width: 14px;
      height: 14px;
      cursor: pointer;
      accent-color: var(--figma-color-bg-brand);
    }

    .image-name {
      cursor: pointer;
      user-select: none;
      font-size: 11px;
      font-weight: 500;
      color: var(--figma-color-text);
    }

    .remove-btn {
      background: none;
      border: none;
      color: var(--figma-color-text-secondary);
      cursor: pointer;
      font-size: 16px;
      padding: 2px;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 3px;
    }

    .remove-btn:hover {
      color: var(--figma-color-text-danger);
      background: var(--figma-color-bg-hover);
    }

    .image-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      align-items: center;
    }

    .image-controls-row {
      display: grid;
      grid-template-columns: 55px 55px 1fr;
      gap: 4px;
      align-items: end;
      max-width: 100%;
      overflow: hidden;
    }

    .image-controls .control-group:nth-child(3) {
      grid-column: 1 / -1;
      justify-self: center;
      max-width: 180px;
      margin-top: 4px;
    }

    .image-controls .control-group:nth-child(3) .control-input[type="range"] {
      width: 100%;
      margin: 2px 0;
    }

    .image-controls .control-group:nth-child(3) .quality-display {
      text-align: center;
      margin-top: 4px;
    }


    .quality-display {
      font-size: 10px;
      font-weight: 600;
      min-width: 30px;
      color: var(--figma-color-text-secondary);
    }

    .control-label {
      font-size: 10px;
      font-weight: 500;
      min-width: 45px;
    }

    .control-label-small {
      font-size: 9px;
      color: var(--figma-color-text-secondary);
      font-weight: 500;
      margin-bottom: 2px;
      display: block;
    }

    .control-input, .control-select {
      flex: 1;
      padding: 4px 6px;
      border: 1px solid var(--figma-color-border);
      border-radius: 4px;
      background: var(--figma-color-bg);
      color: var(--figma-color-text);
      font-size: 10px;
    }

    .control-select-small {
      width: 100%;
      padding: 3px 4px;
      border: 1px solid var(--figma-color-border);
      border-radius: 3px;
      background: var(--figma-color-bg);
      color: var(--figma-color-text);
      font-size: 10px;
      height: 24px;
    }

    .control-slider-small {
      flex: 1;
      min-width: 40px;
      max-width: 80px;
      height: 4px;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .control-label {
      font-size: 10px;
      color: var(--figma-color-text-secondary);
      font-weight: 500;
    }

    .control-input {
      padding: 4px 6px;
      border: 1px solid var(--figma-color-border);
      border-radius: 4px;
      background: var(--figma-color-bg);
      color: var(--figma-color-text);
      font-size: 11px;
    }

    .control-select {
      padding: 4px 6px;
      border: 1px solid var(--figma-color-border);
      border-radius: 4px;
      background: var(--figma-color-bg);
      color: var(--figma-color-text);
      font-size: 11px;
    }

    .presets-section {
      margin-bottom: 12px;
    }

    .presets-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .preset-btn {
      padding: 8px;
      border: 1px solid var(--figma-color-border);
      border-radius: 6px;
      background: var(--figma-color-bg-secondary);
      color: var(--figma-color-text);
      font-size: 10px;
      cursor: pointer;
      text-align: center;
    }

    .preset-btn:hover {
      background: var(--figma-color-bg-hover);
    }

    .preset-title {
      font-weight: 600;
      margin-bottom: 2px;
    }

    .preset-details {
      color: var(--figma-color-text-secondary);
      font-size: 9px;
    }

    .quality-section {
      margin-bottom: 12px;
    }

    .quality-control {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .quality-label {
      font-size: 11px;
      font-weight: 500;
      min-width: 30px;
    }

    .quality-slider {
      flex: 1;
    }

    .quality-value {
      font-size: 11px;
      font-weight: 600;
      min-width: 35px;
      text-align: right;
    }

    .quality-slider-wrapper {
      display: flex;
      align-items: center;
      gap: 3px;
      max-width: 100%;
    }

    .empty-state {
      text-align: center;
      padding: 24px 16px;
      color: var(--figma-color-text-secondary);
    }

    .empty-icon {
      font-size: 32px;
      margin-bottom: 8px;
      opacity: 0.5;
    }

    .progress-section {
      margin-bottom: 16px;
      display: none;
      text-align: center;
    }

    .progress-bar {
      width: 100%;
      max-width: 280px;
      height: 6px;
      background: var(--figma-color-border);
      border-radius: 3px;
      overflow: hidden;
      margin: 0 auto 8px auto;
      position: relative; 
    }


    .progress-fill {
      height: 100%;
      background: var(--figma-color-bg-brand);
      width: 0%;
      transition: width 0.3s ease;
      border-radius: 3px;
      min-width: 0;
      max-width: 100%;
    }

    .progress-text {
      font-size: 11px;
      color: var(--figma-color-text-secondary);
      text-align: center;
    }

    .error-message {
      background: var(--figma-color-bg-danger);
      color: var(--figma-color-text-ondanger);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 11px;
      margin-bottom: 16px;
      display: none;
    }

    .add-button {
      background: var(--figma-color-bg-secondary) !important;
      color: var(--figma-color-text) !important;
      border: 2px solid var(--figma-color-border-success) !important;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      font-weight: 600;
    }

    .add-button:hover {
      background: var(--figma-color-bg-hover) !important;
    }

    .add-button:disabled {
      background: var(--figma-color-bg-disabled) !important;
      color: var(--figma-color-text-disabled) !important;
      border-color: var(--figma-color-border-disabled) !important;
    }

    .add-icon {
      font-size: 16px;
      font-weight: bold;
      line-height: 1;
    }

    .image-controls-compact {
      display: grid;
      grid-template-columns: 80px 70px 1fr;
      gap: 8px;
      align-items: end;
      margin-top: 8px;
    }

    .compact-label {
      font-size: 9px;
      color: var(--figma-color-text-secondary);
      font-weight: 500;
      margin-bottom: 2px;
      display: block;
    }

    .scale-dropdown, .format-dropdown {
      width: 100%;
      padding: 4px 6px;
      border: 1px solid var(--figma-color-border);
      border-radius: 4px;
      background: var(--figma-color-bg);
      color: var(--figma-color-text);
      font-size: 10px;
    }

    .quality-slider-container {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .quality-slider-compact {
      flex: 1;
      min-width: 60px;
    }

    .quality-display-compact {
      font-size: 9px;
      font-weight: 600;
      min-width: 28px;
      color: var(--figma-color-text-secondary);
    }

    .quality-display-small {
      font-size: 8px;
      font-weight: 600;
      min-width: 24px;
      color: var(--figma-color-text-secondary);
      text-align: right;
    }

    .image-item {
      padding: 6px 8px;
      border-bottom: 1px solid var(--figma-color-border);
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .scale-dropdown div {
      padding: 4px 8px;
      font-size: 10px;
      cursor: pointer;
      text-align: center;
    }

    .scale-dropdown div:hover {
      background: var(--figma-color-bg-hover);
    }

    .scale-text-input:focus {
      outline: 2px solid var(--figma-color-border-brand);
      border-color: var(--figma-color-border-brand);
    }

    .scale-dropdown-arrow:focus {
      pointer-events: all;
    }

    .figma-combo-input {
      position: relative;
      display: flex;
      width: 60px;
      z-index: 1;
    }

    .figma-dropdown-btn {
      background: red !important;
      opacity: 0.8 !important;
    }

    .figma-scale-select {
      width: 60px;
      height: 24px;
      padding: 2px 4px;
      border: 1px solid var(--figma-color-border);
      border-radius: 4px;
      background: var(--figma-color-bg);
      color: var(--figma-color-text);
      font-size: 11px;
      outline: none;
      cursor: pointer;
    }

    .figma-scale-select:focus {
      border-color: var(--figma-color-border-brand);
      box-shadow: 0 0 0 1px var(--figma-color-border-brand);
    }

    .figma-scale-select option {
      background: var(--figma-color-bg);
      color: var(--figma-color-text);
    }

    .figma-scale-input {
      width: 100%;
      height: 24px;
      padding: 2px 6px;
      border: 1px solid var(--figma-color-border);
      border-radius: 4px;
      background: var(--figma-color-bg);
      color: var(--figma-color-text);
      font-size: 11px;
      text-align: center;
      outline: none;
    }

    .figma-scale-input:focus {
      border-color: var(--figma-color-border-brand);
      box-shadow: 0 0 0 1px var(--figma-color-border-brand);
    }

    .figma-dropdown-btn {
      position: absolute;
      right: 1px;
      top: 1px;
      width: 18px;
      height: 22px;
      border: none;
      background: transparent;
      color: var(--figma-color-text-secondary);
      font-size: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      pointer-events: auto;
    }

    .figma-dropdown-btn:hover {
      background: var(--figma-color-bg-hover);
      border-radius: 2px;
    }

    .figma-dropdown-menu {
      position: absolute;
      top: 26px;
      left: 0;
      right: 0;
      background: var(--figma-color-bg);
      border: 1px solid var(--figma-color-border);
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      z-index: 9999;
      max-height: 120px;
      overflow-y: auto;
    }

    .figma-dropdown-item {
      padding: 6px 8px;
      font-size: 11px;
      cursor: pointer;
      color: var(--figma-color-text);
    }

    .figma-dropdown-item:hover {
      background: var(--figma-color-bg-hover);
    }

    .figma-dropdown-item:first-child {
      border-radius: 4px 4px 0 0;
    }

    .figma-dropdown-item:last-child {
      border-radius: 0 0 4px 4px;
    }

    .figma-dropdown-menu {
      position: absolute;
      top: 26px;
      left: 0;
      right: 0;
      background: var(--figma-color-bg);
      border: 1px solid var(--figma-color-border);
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      z-index: 1000;
      max-height: 120px;
      overflow-y: auto;
    }

    .figma-dropdown-item {
      padding: 6px 8px;
      font-size: 11px;
      cursor: pointer;
      color: var(--figma-color-text);
    }

    .figma-dropdown-item:hover {
      background: var(--figma-color-bg-hover);
    }

    .scale-input-wrapper {
      position: relative;
      width: 60px;
    }

    .universal-controls {
      background: var(--figma-color-bg-secondary);
      border: 1px solid var(--figma-color-border);
      border-radius: 6px;
      padding: 8px;
      margin-bottom: 8px;
    }

    .universal-control {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .universal-label {
      font-size: 10px;
      color: var(--figma-color-text-secondary);
      font-weight: normal;
    }

    .universal-hint {
      font-size: 10px;
      color: var(--figma-color-text-secondary);
      font-style: italic;
    }

    .quality-section .universal-hint {
      text-align: center;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="title">Image Compression</div>
    <div style="color:rgb(0, 0, 0)" id="selectionStatus" class="selection-status no-selection">
      Please select images in Figma first
    </div>
  </div>
  <div id="errorMessage" class="error-message"></div>
  <div class="presets-section">
    <div class="section-title">Compression Standards</div>
    <div class="presets-grid">
      <button class="preset-btn" onclick="applyPreset('mobile')">
        <div class="preset-title">Mobile</div>
        <div class="preset-details">3X â€¢ 75% â€¢ JPG</div>
      </button>
      <button class="preset-btn" onclick="applyPreset('tablet')">
        <div class="preset-title">Tablet</div>
        <div class="preset-details">2X â€¢ 75% â€¢ JPG</div>
      </button>
      <button class="preset-btn" onclick="applyPreset('room-title')">
        <div class="preset-title">Title</div>
        <div class="preset-details">1X â€¢ 75% â€¢ PNG</div>
      </button>
      <button class="preset-btn" onclick="applyPreset('store-preview')">
        <div class="preset-title">Card</div>
        <div class="preset-details">2X â€¢ 75% â€¢ PNG</div>
      </button>
    </div>
  </div>
  <button id="addSelectedBtn" class="button add-button" onclick="addSelectedObjects()" disabled>
    <span class="add-icon">+</span>
    Add Selected Images
  </button>
  <div class="images-section">
    <div class="section-title">Images to Compress (<span id="imageCount">0</span>)</div>

  <div class="universal-controls">
    <div class="universal-control">
      <label class="control-label-small">Universal Scale</label>
      <select class="figma-scale-select" 
              id="universal-scale"
              onchange="applyUniversalScale(this.value)">
        <option value="">Select scale...</option>
        <option value="0.5">0.5x</option>
        <option value="1">1x</option>
        <option value="1.5">1.5x</option>
        <option value="2">2x</option>
        <option value="2.5">2.5x</option>
        <option value="3">3x</option>
        <option value="4">4x</option>
      </select>
      <span class="universal-hint" id="scale-hint">Apply to all images</span>
    </div>
  </div>


    <div id="imagesList" class="images-list">
      <div class="empty-state">
        <div class="empty-icon">ðŸ“·</div>
        <div>No images added yet</div>
        <div style="font-size: 10px; margin-top: 4px;">Select images in Figma and click "Add Selected Images"</div>
      </div>
    </div>
  </div>

  <!-- Old quality-section
  <div class="quality-section">
    <div class="section-title">Universal Control</div>
    <div class="quality-control">
      <div class="quality-label">JPG</div>
      <input type="range" id="jpgQuality" class="quality-slider" min="10" max="100" value="75">
      <div id="jpgQualityValue" class="quality-value">75%</div>
    </div>
    <div class="quality-control">
      <div class="quality-label">PNG</div>
      <input type="range" id="pngQuality" class="quality-slider" min="10" max="100" value="90">
      <div id="pngQualityValue" class="quality-value">90%</div>
    </div>
  </div>
-->

<!-- New quality-section -->
<div class="quality-section">
  <div class="section-title">Universal Control</div>
  <div class="quality-control">
    <div class="quality-label">JPG</div>
    <input type="range" id="jpgQuality" class="quality-slider" min="10" max="100" value="75" 
           oninput="updateUniversalQuality('jpg', this.value)">
    <div id="jpgQualityValue" class="quality-value">75%</div>
  </div>
  <div class="quality-control">
    <div class="quality-label">PNG</div>
    <input type="range" id="pngQuality" class="quality-slider" min="10" max="100" value="90"
           oninput="updateUniversalQuality('png', this.value)">
    <div id="pngQualityValue" class="quality-value">90%</div>
  </div>
  <div class="universal-hint" id="quality-hint">Apply to all images</div>
</div>


  <div id="progressSection" class="progress-section">
    <div class="progress-bar">
      <div id="progressFill" class="progress-fill"></div>
    </div>
    <div id="progressText" class="progress-text">Processing...</div>
  </div>
  <button id="compressBtn" class="button primary" onclick="compressAndExport()" disabled>
    Compress & Export (<span id="variantCount">0</span> variants)
  </button>
  <script src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.2/dist/browser-image-compression.js"></script>
  <script>

    // Global state
    let currentSelection = [];
    let imageConfigs = [];
    let jpgQuality = 75;
    let pngQuality = 90;
    let selectedImages = new Set();

    // Update image selection
    function updateImageSelection(nodeId, isSelected) {
      if (isSelected) {
        selectedImages.add(nodeId);
      } else {
        selectedImages.delete(nodeId);
      }
      console.log('Selected images:', Array.from(selectedImages));
    }

    // Compression presets
    const PRESETS = {
      'mobile': { scale: 3, format: 'jpg', quality: 75, target: 'Â±180KB' },
      'tablet': { scale: 2, format: 'jpg', quality: 75, target: 'Â±300KB' },
      'room-title': { scale: 1, format: 'png', quality: 75, target: '' },
      'store-preview': { scale: 2, format: 'png', quality: 75, target: '' }
    };

    // Initialize UI
    document.addEventListener('DOMContentLoaded', function() {
      // Setup quality sliders
      const jpgSlider = document.getElementById('jpgQuality');
      const pngSlider = document.getElementById('pngQuality');
      const jpgValue = document.getElementById('jpgQualityValue');
      const pngValue = document.getElementById('pngQualityValue');

      jpgSlider.addEventListener('input', function() {
        jpgQuality = parseInt(this.value);
        jpgValue.textContent = jpgQuality + '%';
        updateImageConfigs();
      });

      pngSlider.addEventListener('input', function() {
        pngQuality = parseInt(this.value);
        pngValue.textContent = pngQuality + '%';
        updateImageConfigs();
      });

      // Request initial selection
      sendMessage({ type: 'get-selection' });
    });

    // Message handling
    onmessage = (event) => {
      const message = event.data.pluginMessage;
      if (!message) return;

      switch (message.type) {
        case 'selection-changed':
          handleSelectionChanged(message);
          break;
        case 'export-results':
          console.log('Received export results:', message.results);
          handleExportResults(message.results);
          break;
        case 'error':
          console.error('TypeScript error:', message.message);
          showError(message.message);
          const btn = document.getElementById('compressBtn');
          btn.disabled = false;
          btn.textContent = `Compress & Export (${imageConfigs.length} variants)`;
          break;
        default:
          console.log('Unknown message:', message);
      }
    };

    function sendMessage(message) {
      parent.postMessage({ pluginMessage: message }, '*');
    }

    function handleSelectionChanged(message) {
      currentSelection = message.selection || [];
      updateSelectionStatus();
    }

    function updateSelectionStatus() {
      const statusEl = document.getElementById('selectionStatus');
      const addBtn = document.getElementById('addSelectedBtn');
      const currentCount = currentSelection.length;
      const imagesCount = imageConfigs.length;

      if (imagesCount > 0) {
        // If we have images in compression list, show success status
        statusEl.className = 'selection-status has-selection';
        statusEl.textContent = `${imagesCount} image${imagesCount === 1 ? '' : 's'} ready to compress`;
        addBtn.disabled = currentCount === 0; // Only disable if no current selection to add
      } else if (currentCount > 0) {
        // If no images in list but current selection exists
        statusEl.className = 'selection-status has-selection';
        statusEl.textContent = `${currentCount} image${currentCount === 1 ? '' : 's'} selected`;
        addBtn.disabled = false;
      } else {
        // No images in list and no current selection
        statusEl.className = 'selection-status no-selection';
        statusEl.textContent = 'Please select images in Figma first';
        addBtn.disabled = true;
      }
    }

    function addSelectedObjects() {
      console.log('addSelectedObjects called');
      console.log('currentSelection:', currentSelection);

      if (currentSelection.length === 0) {
        showError('No images selected');
        return;
      }

      console.log('Adding objects to imageConfigs');

      // Add selected objects to image configs
      currentSelection.forEach(node => {
        if (imageConfigs.find(config => config.nodeId === node.id)) {
          console.log('Skipping duplicate:', node.name); 
          return; // Skip if already added
        }

        console.log('Adding node:', node.name);

        // Determine smart defaults
        const suggestedFormat = node.hasImageFill ? 'jpg' : 'png';
        const suggestedScale = node.hasImageFill ? 2 : 1;

        imageConfigs.push({
          nodeId: node.id,
          nodeName: node.name,
          scale: suggestedScale,
          format: suggestedFormat,
          quality: suggestedFormat === 'jpg' ? jpgQuality : pngQuality
        });
      });

      console.log('imageConfigs after adding:', imageConfigs);
      updateImagesList();
      updateCompressButton();
      updateSelectionStatus(); 
    }

    function removeImage(nodeId) {
      imageConfigs = imageConfigs.filter(config => config.nodeId !== nodeId);
      selectedImages.delete(nodeId);
      updateImagesList();
      updateSelectionStatus();
      updateCompressButton()
    }

    function updateImageConfig(nodeId, field, value) {
      const config = imageConfigs.find(c => c.nodeId === nodeId);
      if (config) {
        config[field] = value;
        if (field === 'format') {
          // Update quality based on format
          config.quality = value === 'jpg' ? jpgQuality : pngQuality;
        }
      }
    }

    function applyPresetToImage(nodeId, presetName) {
      const config = imageConfigs.find(c => c.nodeId === nodeId);
      if (!config) return;

      const presets = {
        'mobile': { scale: 3, format: 'jpg', quality: 75 },
        'tablet': { scale: 2, format: 'jpg', quality: 75 },
        'room-title': { scale: 1, format: 'png', quality: 75 },
        'store-preview': { scale: 2, format: 'png', quality: 75 }
      };

      if (presets[presetName]) {
        const preset = presets[presetName];
        config.scale = preset.scale;
        config.format = preset.format;
        config.quality = preset.quality;
        updateImagesList(); // Refresh the UI
      }
    }

    function updateImageScale(nodeId, value) {
      const config = imageConfigs.find(c => c.nodeId === nodeId);
      if (!config) return;
      
      config.scale = parseFloat(value);
      console.log(`Updated scale for ${nodeId} to ${config.scale}x`);
    }

    function editCustomScale(nodeId) {
      const config = imageConfigs.find(c => c.nodeId === nodeId);
      if (!config) return;
      
      const customValue = prompt('Enter custom scale (e.g., 2.5):', config.scale);
      if (customValue && !isNaN(customValue) && parseFloat(customValue) > 0) {
        config.scale = parseFloat(customValue);
        updateImagesList(); // Refresh to show the new custom option
      }
    }

    function updateImageConfigs() {
      // Only update configs that haven't been individually set
      imageConfigs.forEach(config => {
        // Don't override if this image has a custom quality setting
        if (!config.hasCustomQuality) {
          config.quality = config.format === 'jpg' ? jpgQuality : pngQuality;
        }
      });
      updateImagesList();
    }


    function updateImagesList() {
      const listEl = document.getElementById('imagesList');
      const countEl = document.getElementById('imageCount');
      
      console.log('updateImagesList called, imageConfigs.length:', imageConfigs.length);
      
      countEl.textContent = imageConfigs.length;

      if (imageConfigs.length === 0) {
        listEl.innerHTML = `
          <div class="empty-state">
            <div class="empty-icon">ðŸ“·</div>
            <div>No images added yet</div>
            <div style="font-size: 10px; margin-top: 4px;">Select images in Figma and click "Add Selected Images"</div>
          </div>
        `;
        return;
      }

      // HTML generation
      listEl.innerHTML = imageConfigs.map(config => `
      <div class="image-item">
        <div class="image-header">
          <div class="image-name-container">
            <input type="checkbox" class="image-checkbox" id="checkbox-${config.nodeId}" 
                  ${selectedImages.has(config.nodeId) ? 'checked' : ''}
                  onchange="updateImageSelection('${config.nodeId}', this.checked)">
            <label for="checkbox-${config.nodeId}" class="image-name">${config.nodeName}</label>
          </div>
          <button class="remove-btn" onclick="removeImage('${config.nodeId}')" title="Remove">Ã—</button>
        </div>
        <div class="image-controls-row">
        <div class="scale-control">
          <label class="control-label-small">Scale</label>
          <div class="scale-input-wrapper">
          <input type="text" 
                class="figma-scale-input" 
                value="${config.scale}x" 
                id="scale-input-${config.nodeId}"
                onblur="updateScaleFromInput('${config.nodeId}', this.value)"
                onkeypress="if(event.key==='Enter') this.blur()"
                onfocus="showAllScaleOptions('${config.nodeId}')"
                onclick="showAllScaleOptions('${config.nodeId}')"
                list="scale-options-${config.nodeId}">
            <datalist id="scale-options-${config.nodeId}">
              <option value="0.5x">0.5x</option>
              <option value="1x">1x</option>
              <option value="1.5x">1.5x</option>
              <option value="2x">2x</option>
              <option value="2.5x">2.5x</option>
              <option value="3x">3x</option>
              <option value="4x">4x</option>
            </datalist>
          </div>
        </div>
          <div class="format-control">
            <label class="control-label-small">Format</label>
            <select class="control-select-small" onchange="updateImageConfig('${config.nodeId}', 'format', this.value)">
              <option value="jpg" ${config.format === 'jpg' ? 'selected' : ''}>JPG</option>
              <option value="png" ${config.format === 'png' ? 'selected' : ''}>PNG</option>
            </select>
          </div>
          <div class="quality-control">
            <label class="control-label-small">Quality</label>
            <div class="quality-slider-wrapper">
              <input type="range" class="control-slider-small" min="10" max="100" value="${config.quality}" 
                    oninput="updateQualityDisplay('${config.nodeId}', this.value)" 
                    onchange="updateImageConfig('${config.nodeId}', 'quality', parseInt(this.value))">
              <span class="quality-display-small" id="quality-display-${config.nodeId}">${config.quality}%</span>
            </div>
          </div>
        </div>
      </div>
      `).join('');
      console.log('HTML generated successfully');
      adjustPluginHeight();

      updateScaleHint();
      updateQualityHint();
    }

    function adjustPluginHeight() {
      const baseHeight = 620;
      const itemHeight = 45;
      const maxVisibleItems = 5;
      const additionalItems = Math.max(0, imageConfigs.length - maxVisibleItems);
      const newHeight = Math.min(baseHeight + (additionalItems * itemHeight), 850); // Max 850px
      
      parent.postMessage({
        pluginMessage: {
          type: 'resize-plugin',
          width: 320,
          height: newHeight
        }
      }, '*');
    }

    function getPresetForConfig(config) {
      const presets = {
        'mobile': { scale: 3, format: 'jpg', quality: 75 },
        'tablet': { scale: 2, format: 'jpg', quality: 75 },
        'room-title': { scale: 1, format: 'png', quality: 75 },
        'store-preview': { scale: 2, format: 'png', quality: 75 }
      };

      for (const [name, preset] of Object.entries(presets)) {
        if (config.scale === preset.scale && 
            config.format === preset.format && 
            config.quality === preset.quality) {
          return name;
        }
      }
      return 'custom';
    }

    function updateQualityDisplay(nodeId, value) {
      const displayEl = document.getElementById(`quality-display-${nodeId}`);
      if (displayEl) {
        displayEl.textContent = value + '%';
      }
    }

    function updateImageConfigAndDisplay(nodeId, field, value, element) {
      updateImageConfig(nodeId, field, value);
      // Update the display immediately
      const displayEl = document.getElementById(`quality-${nodeId}`);
      if (displayEl) {
        displayEl.textContent = value + '%';
      }
    }

    function updateScaleFromText(nodeId, value) {
      const config = imageConfigs.find(c => c.nodeId === nodeId);
      if (!config) return;
      
      // Extract number from text
      const numValue = parseFloat(value.replace('x', ''));
      if (!isNaN(numValue) && numValue > 0 && numValue <= 10) {
        config.scale = numValue;
        // Update the input to show clean format
        document.getElementById(`scale-input-${nodeId}`).value = `${numValue}x`;
      } else {
        // Reset to current value if invalid
        document.getElementById(`scale-input-${nodeId}`).value = `${config.scale}x`;
      }
    }

    function updateScaleFromDropdown(nodeId, value) {
      if (!value) return; // Ignore the arrow option
      
      const config = imageConfigs.find(c => c.nodeId === nodeId);
      if (!config) return;
      
      config.scale = parseFloat(value);
      // Update the text input
      document.getElementById(`scale-input-${nodeId}`).value = `${config.scale}x`;
      
      // Reset dropdown to arrow
      event.target.value = "";
    }

    function updateCompressButton() {
      const btn = document.getElementById('compressBtn');
      const countEl = document.getElementById('variantCount');
      
      countEl.textContent = imageConfigs.length;
      btn.disabled = imageConfigs.length === 0;
    }

    function applyPreset(presetName) {
      // Check if any images are selected
      if (selectedImages.size === 0) {
        showError('Please select the images you want to apply this preset to.');
        return;
      }

      const preset = PRESETS[presetName];
      if (!preset) return;

      // Apply preset only to selected images
      selectedImages.forEach(nodeId => {
        const config = imageConfigs.find(c => c.nodeId === nodeId);
        if (config) {
          config.scale = preset.scale;
          config.format = preset.format;
          config.quality = preset.quality;
        }
      });

      // Clear selections after applying preset
      selectedImages.clear();

      // Refresh the UI
      updateImagesList();
      updateCompressButton();
      
      console.log(`Applied ${presetName} preset and cleared selections`);
    }

    async function compressAndExport() {
      if (imageConfigs.length === 0) {
        showError('No images to compress');
        return;
      }

      const btn = document.getElementById('compressBtn');
      const originalText = btn.textContent;
      
      try {
        btn.disabled = true;
        btn.textContent = 'Starting export...';
        hideError();
        
        console.log('Sending export request with configs:', imageConfigs);
        
        // Send export request to TypeScript
        parent.postMessage({
          pluginMessage: {
            type: 'export-images',
            imageConfigs: imageConfigs
          }
        }, '*');
      }
      catch (error) {
        console.error('Export initiation failed:', error);
        showError('Export failed: ' + error.message);
        btn.disabled = false;
        btn.textContent = originalText;
      }
    }

    function downloadSingleImage(compressedBytes, nodeName, format) {
      const blob = new Blob([new Uint8Array(compressedBytes)]);
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${nodeName}.${format}`;
      a.click();
      URL.revokeObjectURL(url);
    }

    function showAllScaleOptions(nodeId) {
      const input = document.getElementById(`scale-input-${nodeId}`);
      
      // Clear the input temporarily to show all options
      const currentValue = input.value;
      input.value = '';
      // Trigger the datalist to show all options
      input.focus();
      // Restore the value after a brief moment
      setTimeout(() => {
        if (document.activeElement === input) {
          input.value = currentValue;
          input.select();
        }
      }, 50);
    }

    async function handleExportResults(results) {
      try {
        // SINGLE IMAGE - Download directly
        if (results.length === 1 && results[0].success) {
          const result = results[0];
          showProgress(25, `Compressing: ${result.nodeName}`);
          
          try {
            console.log('Single image processing:', result.nodeName);
            
            // Convert to file for compression
            const blob = new Blob([result.originalBytes], { 
              type: result.config.format === 'jpg' ? 'image/jpeg' : 'image/png' 
            });
            const file = new File([blob], `${result.nodeName}.${result.config.format}`, { 
              type: blob.type 
            });

            let compressedBytes;
            if (result.config.format === 'jpg') {
                const figmaScale = result.config.scale;
                let maxDimension;
                if (figmaScale >= 3.0) {
                  maxDimension = 6144;
                } 
                else if (figmaScale >= 2.5) {
                  maxDimension = 5120;
                } 
                else if (figmaScale >= 2.0) {
                  maxDimension = 4096;
                } 
                else if (figmaScale >= 1.5) {
                  maxDimension = 3072;
                } 
                else {
                  maxDimension = 2048;
                }

              const options = {
                maxSizeMB: 0.5,
                maxWidthOrHeight: maxDimension,
                useWebWorker: true,
                quality: Math.max(0.1, Math.min(0.95, result.config.quality / 100)),
                initialQuality: Math.max(0.1, Math.min(0.95, result.config.quality / 100)),
                alwaysKeepResolution: false,
                fileType: 'image/jpeg'
              };
              const compressedFile = await imageCompression(file, options);
              compressedBytes = await compressedFile.arrayBuffer();
            }
            else if (result.config.format === 'png') {
              // PNG compression with same aggressive logic
              const pngQuality = result.config.quality / 100;
              const originalSizeMB = file.size / (1024 * 1024);
              const isComplexImage = originalSizeMB > 0.18;

              const targetSizeMB = isComplexImage ? 
                (pngQuality > 0.9 ? 0.5 : pngQuality > 0.8 ? 0.3 : pngQuality > 0.7 ? 0.2 : 
                pngQuality > 0.5 ? 0.15 : pngQuality > 0.3 ? 0.1 : 0.08) :
                (pngQuality > 0.9 ? 0.15 : pngQuality > 0.8 ? 0.08 : pngQuality > 0.7 ? 0.06 : 
                pngQuality > 0.5 ? 0.05 : pngQuality > 0.3 ? 0.04 : 0.03);

              const figmaScale = result.config.scale;
              let maxDimension;
              if (figmaScale >= 3.0) {
                maxDimension = 6144;
              } 
              else if (figmaScale >= 2.5) {
                maxDimension = 5120;
              } 
              else if (figmaScale >= 2.0) {
                maxDimension = 4096;
              } 
              else if (figmaScale >= 1.5) {
                maxDimension = 3072;
              } 
              else {
                maxDimension = 2048;
              }

              const ultraOptions = {
                maxSizeMB: targetSizeMB,
                maxWidthOrHeight: maxDimension,
                useWebWorker: true,
                quality: Math.max(0.4, pngQuality * 0.7),
                fileType: 'image/png',
                preserveExif: false,
                alwaysKeepResolution: true,
                maxIteration: 30
              };
              const compressedFile = await imageCompression(file, ultraOptions);
              compressedBytes = await compressedFile.arrayBuffer();
            }

            // Download single image directly
            showProgress(75, 'Creating download...');
            const finalBlob = new Blob([new Uint8Array(compressedBytes)]);
            const url = URL.createObjectURL(finalBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${result.nodeName}@${result.config.scale}x_${result.config.quality}.${result.config.format}`;
            a.click();
            URL.revokeObjectURL(url);
            showProgress(100, 'Complete!');
            hideProgress();
            showSuccess(`Exported ${result.nodeName}`);
            resetCompressButton();
            return;
          }
          catch (error) {
            console.error('Single image compression failed:', error);
            showError(`Failed to compress ${result.nodeName}: ${error.message}`);
            hideProgress();
            resetCompressButton();
            return;
          }
        }

        // Handle single image export failure
        if (results.length === 1 && !results[0].success) {
          showError(`Export failed for ${results[0].nodeName}: ${results[0].error}`);
          hideProgress();
          return;
        }

        // MULTIPLE IMAGES
        const compressedImages = [];
        let processed = 0;

        for (const result of results) {
          if (!result.success) {
            console.error('Export failed for:', result.nodeName, result.error);
            showError(`Export failed for ${result.nodeName}: ${result.error}`);
            processed++;
            showProgress((processed / results.length) * 50, `Failed: ${result.nodeName}`);
            continue;
          }

          showProgress((processed / results.length) * 50, `Compressing: ${result.nodeName}`);
          try {
            console.log('Processing:', result.nodeName, 'Size:', result.originalBytes.length, 'Format:', result.config.format);

            // Convert Uint8Array to File for compression
            const blob = new Blob([result.originalBytes], { 
              type: result.config.format === 'jpg' ? 'image/jpeg' : 'image/png' 
            });
            
            const file = new File([blob], `${result.nodeName}.${result.config.format}`, { 
              type: blob.type 
            });

            // Format specific compression options
            let compressedBytes;
            if (result.config.format === 'jpg') {

              const figmaScale = result.config.scale;
              let maxDimension;
              if (figmaScale >= 3.0) {
                maxDimension = 6144;
              }
              else if (figmaScale >= 2.5) {
                maxDimension = 5120;
              }
              else if (figmaScale >= 2.0) {
                maxDimension = 4096;
              }
              else if (figmaScale >= 1.5) {
                maxDimension = 3072;
              }
              else {
                maxDimension = 2048;
              }

              // JPG compression
              const options = {
                maxSizeMB: 0.5,
                maxWidthOrHeight: maxDimension,
                useWebWorker: true,
                quality: Math.max(0.1, Math.min(0.95, result.config.quality / 100)),
                initialQuality: Math.max(0.1, Math.min(0.95, result.config.quality / 100)),
                alwaysKeepResolution: true,
                fileType: 'image/jpeg'
              };
              
              const compressedFile = await imageCompression(file, options);
              compressedBytes = await compressedFile.arrayBuffer();
            }
            else if (result.config.format === 'png') {
              // AGGRESSIVE PNG COMPRESSION
              const pngQuality = result.config.quality / 100;
              
              // Content-aware compression based on original file size
              const originalSizeMB = file.size / (1024 * 1024);
              const isComplexImage = originalSizeMB > 0.18;

              // AGGRESSIVE size limits
              const targetSizeMB = isComplexImage ? 
                (pngQuality > 0.9 ? 0.5 : pngQuality > 0.8 ? 0.3 : pngQuality > 0.7 ? 0.2 : 
                pngQuality > 0.5 ? 0.15 : pngQuality > 0.3 ? 0.1 : 0.08) :
                (pngQuality > 0.9 ? 0.15 : pngQuality > 0.8 ? 0.08 : pngQuality > 0.7 ? 0.06 : 
                pngQuality > 0.5 ? 0.05 : pngQuality > 0.3 ? 0.04 : 0.03);

              const figmaScale = result.config.scale;
              let maxDimension;
              if (figmaScale >= 3.0) {
                maxDimension = 6144;
              }
              else if (figmaScale >= 2.5) {
                maxDimension = 5120;
              }
              else if (figmaScale >= 2.0) {
                maxDimension = 4096;
              }
              else if (figmaScale >= 1.5) {
                maxDimension = 3072;
              }
              else {
                maxDimension = 2048;
              }

              // More aggressive compression options
              const ultraOptions = {
                maxSizeMB: targetSizeMB,
                maxWidthOrHeight: maxDimension,
                useWebWorker: true,
                quality: Math.max(0.4, pngQuality * 0.7),
                fileType: 'image/png',
                preserveExif: false,
                alwaysKeepResolution: true,
                maxIteration: 30
              };
      
              try {
                const compressedFile = await imageCompression(file, ultraOptions);
                compressedBytes = await compressedFile.arrayBuffer();
                
                // Smart fallback for better compression if needed
                if (compressedFile.size > (targetSizeMB * 1024 * 1024)) {
                  const smartOptions = {
                    maxSizeMB: targetSizeMB * 0.8,
                    maxWidthOrHeight: maxDimension,
                    useWebWorker: true,
                    quality: Math.max(0.3, pngQuality * 0.6),
                    fileType: 'image/png',
                    preserveExif: false,
                    alwaysKeepResolution: true,
                    maxIteration: 50
                  };
                  
                  const smartFile = await imageCompression(file, smartOptions);
                  if (smartFile.size < compressedFile.size) {
                    compressedBytes = await smartFile.arrayBuffer();
                  }
                }
              }
              catch (error) {
                console.error('PNG Ultra compression failed:', error);
                throw error;
              }
            }
            else {
              throw new Error(`Unsupported format: ${result.config.format}`);
            }

            // Generate filename and add to results
            const filename = `${result.nodeName}@${result.config.scale}x_${result.config.quality}.${result.config.format}`;
            compressedImages.push({
              filename,
              data: new Uint8Array(compressedBytes),
              originalSize: result.originalBytes.length,
              compressedSize: compressedBytes.byteLength
            });
            
          } catch (compressionError) {
            console.error('Compression failed for:', result.nodeName, compressionError);
            showError(`Compression failed for ${result.nodeName}: ${compressionError.message}`);
          
            // Add the original image without compression as fallback
            const filename = `${result.nodeName}@${result.config.scale}x_original.${result.config.format}`;
            compressedImages.push({
              filename,
              data: result.originalBytes,
              originalSize: result.originalBytes.length,
              compressedSize: result.originalBytes.length
            });
            resetCompressButton();
          }
          processed++;
          showProgress(50 + (processed / results.length) * 50, `Processed: ${result.nodeName}`);
        }

        if (compressedImages.length === 0) {
          showError('No images were successfully processed');
          hideProgress();
          return;
        }

        // Create and download ZIP
        showProgress(100, 'Creating download...');
        await downloadAsZip(compressedImages);
        hideProgress();
        showSuccess(`Successfully processed ${compressedImages.length} image${compressedImages.length === 1 ? '' : 's'}!`);
        resetCompressButton();
      } 
      catch (error) {
        console.error('Processing failed:', error);
        showError('Processing failed: ' + error.message);
        hideProgress();
        resetCompressButton();
      }
    }

    async function downloadAsZip(images) {
      const zip = new JSZip();
      images.forEach(image => {
        zip.file(image.filename, image.data);
      });
      const zipBlob = await zip.generateAsync({ type: 'blob' });
      
      // Download
      const url = URL.createObjectURL(zipBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'compressed-images.zip';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function showProgress(percent, text) {
      const section = document.getElementById('progressSection');
      const fill = document.getElementById('progressFill');
      const textEl = document.getElementById('progressText');
      
      section.style.display = 'block';
      fill.style.width = percent + '%';
      textEl.textContent = text;
    }

    function hideProgress() {
      document.getElementById('progressSection').style.display = 'none';
    }

    function showError(message) {
      const errorEl = document.getElementById('errorMessage');
      if (errorEl) {
        errorEl.textContent = message;
        errorEl.style.display = 'block';
        
        // Auto hide after 5 seconds
        setTimeout(() => {
          hideError();
        }, 5000);
      }
      console.error('Plugin Error:', message);
    }

    function hideError() {
      const errorEl = document.getElementById('errorMessage');
      if (errorEl) {
        errorEl.style.display = 'none';
      }
    }

    function resetCompressButton() {
      const btn = document.getElementById('compressBtn');
      const countEl = document.getElementById('variantCount');
      btn.disabled = imageConfigs.length === 0;
      btn.textContent = `Compress & Export (${imageConfigs.length} variant${imageConfigs.length === 1 ? '' : 's'})`;
    }

    function showSuccess(message) {
      // Temporarily show success in the error element with different styling
      const errorEl = document.getElementById('errorMessage');
      errorEl.textContent = message;
      errorEl.style.display = 'block';
      errorEl.style.background = 'var(--figma-color-bg-success)';
      errorEl.style.color = 'var(--figma-color-text-success)';
      
      setTimeout(() => {
        hideError();
        errorEl.style.background = 'var(--figma-color-bg-danger)';
        errorEl.style.color = 'var(--figma-color-text-ondanger)';
      }, 3000);
    }

    // Load JSZip library properly
    function loadJSZip() {
      return new Promise((resolve, reject) => {
        if (window.JSZip) {
          resolve();
          return;
        }
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';
        script.onload = ( ) => resolve();
        script.onerror = () => reject(new Error('Failed to load JSZip'));
        document.head.appendChild(script);
      });
    }

    // Load JSZip on page load
    loadJSZip().catch(console.error);

    console.log(' SCRIPT LOADED - Testing event listener setup');

    // Test if elements exist
    setTimeout(() => {
      const buttons = document.querySelectorAll('.figma-dropdown-btn');
      console.log('ðŸ” Found dropdown buttons:', buttons.length);
      
      buttons.forEach((btn, index) => {
        console.log(`Button ${index}:`, btn.className, btn.getAttribute('data-node-id'));
      });
    }, 1000);

    // Direct button click handler as backup
    function handleDropdownClick(nodeId) {
      console.log('DIRECT FUNCTION CALLED:', nodeId);
      toggleScaleDropdown(nodeId);
    }

    function updateScaleFromInput(nodeId, value) {
      console.log('Scale input updated:', nodeId, value);
      const config = imageConfigs.find(c => c.nodeId === nodeId);
      if (!config) return;
      
      // Extract number from text
      const numValue = parseFloat(value.replace('x', ''));
      if (!isNaN(numValue) && numValue > 0 && numValue <= 10) {
        config.scale = numValue;
        // Update the input to show clean format
        document.getElementById(`scale-input-${nodeId}`).value = `${numValue}x`;
        console.log('Scale updated to:', numValue);
        updateImagesList()
      } 
      else {
        // Reset to current value if invalid
        document.getElementById(`scale-input-${nodeId}`).value = `${config.scale}x`;
        console.log('Invalid scale value, reset to:', config.scale);
      }
    }

    function applyUniversalScale(scaleValue) {
      if (!scaleValue) return;
      
      const scale = parseFloat(scaleValue);
      const targetImages = getTargetImages();
      
      console.log(`Applying universal scale ${scale}x to:`, targetImages);
      
      targetImages.forEach(nodeId => {
        const config = imageConfigs.find(c => c.nodeId === nodeId);
        if (config) {
          config.scale = scale;
        }
      });
      
      updateImagesList();
      updateScaleHint();
      
      // Reset the dropdown
      document.getElementById('universal-scale').value = '';
    }

    function updateUniversalQuality(format, value) {
      const quality = parseInt(value);
      const targetImages = getTargetImages();
      
      console.log(`Applying universal ${format.toUpperCase()} quality ${quality}% to:`, targetImages);
      
      // Update slider display
      if (format === 'jpg') {
        document.getElementById('jpgQualityValue').textContent = quality + '%';
      } else {
        document.getElementById('pngQualityValue').textContent = quality + '%';
      }
      
      // Apply ONLY to target images (don't update global variables)
      targetImages.forEach(nodeId => {
        const config = imageConfigs.find(c => c.nodeId === nodeId);
        if (config && config.format === format) {
          config.quality = quality;
          config.hasCustomQuality = true;  // â† MARK AS CUSTOM
        }
      });
      // Update ONLY the affected images, not all
      updateImagesList();
      updateQualityHint();
    }


    function getTargetImages() {
      // If no images are selected, return all images
      if (selectedImages.size === 0) {
        return imageConfigs.map(config => config.nodeId);
      }
      
      // Return only selected images
      return Array.from(selectedImages);
    }

    function updateScaleHint() {
      const hint = document.getElementById('scale-hint');
      if (selectedImages.size === 0) {
        hint.textContent = `Apply to all ${imageConfigs.length} images`;
      } else {
        hint.textContent = `Apply to ${selectedImages.size} selected images`;
      }
    }

    function updateQualityHint() {
      const hint = document.getElementById('quality-hint');
      if (selectedImages.size === 0) {
        hint.textContent = `Apply to all ${imageConfigs.length} images`;
      } else {
        hint.textContent = `Apply to ${selectedImages.size} selected images`;
      }
    }

    // Update hints when selection changes
    function updateImageSelection(nodeId, isSelected) {
      if (isSelected) {
        selectedImages.add(nodeId);
      } else {
        selectedImages.delete(nodeId);
      }
      
      console.log('Selected images:', Array.from(selectedImages));
      updateScaleHint();
      updateQualityHint();
    }
  </script>
</body>
</html>